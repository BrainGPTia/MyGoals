console.log('ðŸš€ Chargement de Focus & Zen...');

document.addEventListener('DOMContentLoaded', function() {
    console.log('âœ… DOM chargÃ©, initialisation...');
    
    // ========================================================== //
    // 1. SÃ‰LECTION DES Ã‰LÃ‰MENTS DU DOM
    // ========================================================== //
    
    const body = document.body;
    const homeButton = document.getElementById('home-button');
    const faqButton = document.getElementById('faq-button');
    const focusPage = document.getElementById('focus-page');
    const faqPage = document.getElementById('faq-page');

    const audio = document.getElementById('background-audio');
    const audioToggleButton = document.getElementById('audio-toggle-button');
    const nextTrackButton = document.getElementById('next-track-button');
    const currentTrackInfo = document.getElementById('current-track-info');
    const volumeSlider = document.getElementById('volume-slider');

    const modalOverlay = document.getElementById('modal-overlay');
    const closeModalButton = document.querySelector('.close-modal-button');
    const settingsButton = document.getElementById('settings-button');
    const themeSwitch = document.getElementById('theme-switch');
    const animationSwitch = document.getElementById('animation-switch');

    const quoteElement = document.getElementById('motivational-quote');
    const changeQuoteButton = document.getElementById('change-quote-button');
    const dailyGoalInput = document.getElementById('daily-goal');
    const newTodoInput = document.getElementById('new-todo');
    const addTodoButton = document.getElementById('add-todo-button');
    const todoListElement = document.getElementById('todo-list');
    const todoCountElement = document.getElementById('todo-count');
    
    const timerDisplay = document.getElementById('timer-display');
    const startTimerButton = document.getElementById('start-timer');
    const resetTimerButton = document.getElementById('reset-timer');
    const timerStatus = document.getElementById('timer-status');
    const sessionCountElement = document.getElementById('session-count');
    const workDurationInline = document.getElementById('work-duration-inline');
    const breakDurationInline = document.getElementById('break-duration-inline');
    
    const canvas = document.getElementById('drawing-canvas');
    const clearCanvasButton = document.getElementById('clear-canvas');
    const toolPencilButton = document.getElementById('tool-pencil');
    const toolEraserButton = document.getElementById('tool-eraser');
    const colorPicker = document.getElementById('color-picker');
    const brushSize = document.getElementById('brush-size');
    const brushSizeValue = document.getElementById('brush-size-value');

    console.log('âœ… Ã‰lÃ©ments DOM sÃ©lectionnÃ©s');

    // ========================================================== //
    // 2. GESTION DES DONNÃ‰ES LOCALES
    // ========================================================== //
    
    const loadState = function(key, defaultValue) {
        try {
            const stored = localStorage.getItem(key);
            if (stored === null) return defaultValue;
            return JSON.parse(stored);
        } catch (error) {
            console.warn('Erreur chargement ' + key + ':', error);
            return defaultValue;
        }
    };

    const saveState = function(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
        } catch (error) {
            console.error('Erreur sauvegarde ' + key + ':', error);
        }
    };

    // ========================================================== //
    // 3. GESTION DE LA PLAYLIST & AUDIO
    // ========================================================== //
    
    const playlist = [
        { title: "Calm Focus", url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" }, 
        { title: "Deep Ambient", url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3" }, 
        { title: "Zen Loop", url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3" },
        { title: "Synthwave", url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3" },
        { title: "Flow State", url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3" }
    ];
    
    let currentTrackIndex = loadState('currentTrackIndex', 0);

    const loadTrack = function(index) {
        if (index < 0 || index >= playlist.length) {
            index = 0;
        }
        audio.src = playlist[index].url;
        audio.load();
        currentTrackIndex = index;
        saveState('currentTrackIndex', index);
        updateAudioButtonState();
    };
    
    const updateAudioButtonState = function() {
        const icon = audio.paused ? 'play' : 'pause';
        audioToggleButton.innerHTML = '<i class="fas fa-' + icon + '"></i>';
        currentTrackInfo.textContent = playlist[currentTrackIndex].title;
    };

    const toggleAudio = function() {
        if (audio.paused) {
            audio.play().catch(function(error) {
                console.error("Erreur lecture:", error);
                alert("Le navigateur a bloquÃ© la lecture. Cliquez Ã  nouveau.");
            });
        } else {
            audio.pause();
        }
    };

    const playNextTrack = function() {
        const wasPlaying = !audio.paused;
        currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
        loadTrack(currentTrackIndex);
        if (wasPlaying) {
            audio.play().catch(function(error) {
                console.error("Erreur changement piste:", error);
            });
        }
    };

    const initialVolume = loadState('audioVolume', 0.5);
    audio.volume = Math.min(Math.max(initialVolume, 0), 1);
    
    if (volumeSlider) {
        volumeSlider.value = initialVolume;
        volumeSlider.addEventListener('input', function() {
            const volume = parseFloat(volumeSlider.value);
            audio.volume = volume;
            saveState('audioVolume', volume);
        });
    }

    audioToggleButton.addEventListener('click', toggleAudio);
    nextTrackButton.addEventListener('click', playNextTrack);
    audio.addEventListener('ended', playNextTrack);
    audio.addEventListener('play', updateAudioButtonState);
    audio.addEventListener('pause', updateAudioButtonState);

    loadTrack(currentTrackIndex);
    console.log('âœ… Audio initialisÃ©');

    // ========================================================== //
    // 4. GESTION DE LA NAVIGATION
    // ========================================================== //

    const navigateTo = function(targetPageElement, sourceButton) {
        const allPages = document.querySelectorAll('.page-section');
        for (let i = 0; i < allPages.length; i++) {
            allPages[i].classList.remove('visible-page-section');
            allPages[i].classList.add('hidden-page-section');
        }

        targetPageElement.classList.remove('hidden-page-section');
        targetPageElement.classList.add('visible-page-section');

        const allButtons = document.querySelectorAll('.nav-button');
        for (let i = 0; i < allButtons.length; i++) {
            allButtons[i].classList.remove('active-nav-button');
        }
        
        if (sourceButton) {
            sourceButton.classList.add('active-nav-button');
        }
        
        window.scrollTo({ top: 0, behavior: 'smooth' });
    };

    homeButton.addEventListener('click', function() {
        console.log('Navigation: Accueil');
        navigateTo(focusPage, homeButton);
    });
    
    faqButton.addEventListener('click', function() {
        console.log('Navigation: FAQ');
        navigateTo(faqPage, faqButton);
    });

    console.log('âœ… Navigation initialisÃ©e');

    // ========================================================== //
    // 5. GESTION DES MODALES
    // ========================================================== //

    const openModal = function() {
        modalOverlay.classList.remove('hidden-modal');
        body.style.overflow = 'hidden';
    };

    const closeModal = function() {
        modalOverlay.classList.add('hidden-modal');
        body.style.overflow = '';
    };
    
    settingsButton.addEventListener('click', function() {
        console.log('Ouverture paramÃ¨tres');
        openModal();
    });
    
    closeModalButton.addEventListener('click', function() {
        console.log('Fermeture paramÃ¨tres');
        closeModal();
    });
    
    modalOverlay.addEventListener('click', function(e) {
        if (e.target === modalOverlay) {
            closeModal();
        }
    });

    // ThÃ¨me
    const currentTheme = loadState('theme', 'light');
    if (currentTheme === 'dark') {
        body.classList.add('dark-mode');
        if (themeSwitch) themeSwitch.checked = true;
    }

    if (themeSwitch) {
        themeSwitch.addEventListener('change', function() {
            const isDark = themeSwitch.checked;
            if (isDark) {
                body.classList.add('dark-mode');
            } else {
                body.classList.remove('dark-mode');
            }
            saveState('theme', isDark ? 'dark' : 'light');
            if (canvas) setupCanvas();
            console.log('ThÃ¨me changÃ©:', isDark ? 'sombre' : 'clair');
        });
    }

    // Animations
    const toggleAnimations = function(enable) {
        const value = enable ? '0.25s' : '0s';
        document.documentElement.style.setProperty('--transition-speed', value);
        saveState('animationsEnabled', enable);
    };
    
    const animationsEnabled = loadState('animationsEnabled', true);
    if (animationSwitch) {
        animationSwitch.checked = animationsEnabled;
        toggleAnimations(animationsEnabled);
        animationSwitch.addEventListener('change', function() {
            toggleAnimations(animationSwitch.checked);
        });
    }

    console.log('âœ… ParamÃ¨tres initialisÃ©s');

    // ========================================================== //
    // 6. FAQ
    // ========================================================== //
    
    const faqData = [
        {
            question: "Qui a crÃ©Ã© ce site ?",
            answer: "Ce site a Ã©tÃ© conÃ§u par un dÃ©veloppeur visant Ã  crÃ©er un espace de travail numÃ©rique sans distraction, se concentrant uniquement sur l'efficacitÃ© des mÃ©thodes Ã©prouvÃ©es (Pomodoro, To-Do minimaliste)."
        },
        {
            question: "Pourquoi ces fonctionnalitÃ©s limitÃ©es ?",
            answer: "C'est un choix dÃ©libÃ©rÃ© pour Ã©viter la surcharge cognitive. Chaque outil sert un but prÃ©cis : le Minuteur gÃ¨re le temps, la To-Do gÃ¨re l'organisation minimale, et la Zone de dessin permet la dÃ©tente active ou le 'doodling' sans basculer sur une autre application."
        },
        {
            question: "La musique est-elle vraiment libre de droits ?",
            answer: "Les pistes utilisÃ©es sont des URLs de dÃ©monstration provenant de sources libres de droits (SoundHelix). Dans une version finale, ces pistes seraient remplacÃ©es par des musiques ambient et lo-fi spÃ©cifiquement sÃ©lectionnÃ©es pour la concentration et le relaxement."
        },
        {
            question: "OÃ¹ sont stockÃ©es mes donnÃ©es ?",
            answer: "Toutes les donnÃ©es (Objectif, To-Do, ThÃ¨me, DurÃ©es Pomodoro) sont stockÃ©es exclusivement dans le <strong>localStorage</strong> de votre navigateur. Elles ne quittent jamais votre appareil, garantissant la confidentialitÃ© et l'accÃ¨s instantanÃ©."
        }
    ];

    const renderFAQ = function() {
        const container = faqPage.querySelector('#faq-content');
        if (!container) return;
        
        container.innerHTML = '<div class="faq-introduction"><h2><i class="fas fa-question-circle"></i> Pourquoi Focus & Zen ?</h2><p>Cette section dÃ©taille la philosophie et les choix de conception derriÃ¨re Focus & Zen.</p></div>';
        
        for (let i = 0; i < faqData.length; i++) {
            const item = faqData[i];
            const section = document.createElement('div');
            section.style.marginBottom = '30px';
            
            const question = document.createElement('h3');
            question.innerHTML = 'Q: ' + item.question;
            
            const answer = document.createElement('p');
            answer.innerHTML = 'R: ' + item.answer;
            
            section.appendChild(question);
            section.appendChild(answer);
            container.appendChild(section);
        }
    };
    
    renderFAQ();

    // ========================================================== //
    // 7. CITATIONS
    // ========================================================== //
    
    const quotes = [
        "La simplicitÃ© est la sophistication suprÃªme. - Leonardo da Vinci",
        "Ne remettez jamais Ã  demain ce que vous pouvez faire aprÃ¨s-demain. - Mark Twain",
        "Le secret pour avancer est de commencer. - Mark Twain",
        "Concentrez toute votre Ã©nergie sur la tÃ¢che que vous avez Ã  accomplir. - Bouddha",
        "Un petit pas vaut mieux qu'une longue mÃ©ditation. - Proverbe tibÃ©tain",
        "La perfection est atteinte non pas lorsqu'il n'y a plus rien Ã  ajouter, mais lorsqu'il n'y a plus rien Ã  retirer. - Antoine de Saint-ExupÃ©ry",
        "Ce qui compte, ce n'est pas le nombre d'heures que vous mettez dans votre travail, c'est le travail que vous mettez dans vos heures. - Sam Ewing"
    ];

    const displayRandomQuote = function() {
        if (quoteElement) {
            const randomIndex = Math.floor(Math.random() * quotes.length);
            quoteElement.textContent = quotes[randomIndex];
        }
    };

    displayRandomQuote();
    
    if (changeQuoteButton) {
        changeQuoteButton.addEventListener('click', function() {
            console.log('Changement de citation');
            displayRandomQuote();
        });
    }
    
    if (quoteElement) {
        quoteElement.style.cursor = 'pointer';
        quoteElement.addEventListener('click', displayRandomQuote);
    }

    console.log('âœ… Citations initialisÃ©es');

    // ========================================================== //
    // 8. OBJECTIF - SAUVEGARDE AUTOMATIQUE
    // ========================================================== //
    
    if (dailyGoalInput) {
        const savedGoal = loadState('dailyGoal', '');
        dailyGoalInput.value = savedGoal;
        
        dailyGoalInput.addEventListener('input', function() {
            saveState('dailyGoal', dailyGoalInput.value.trim());
        });
    }

    console.log('âœ… Objectif initialisÃ©');

    // ========================================================== //
    // 9. TO-DO LIST
    // ========================================================== //
    
    let todos = loadState('todos', []);

    const renderTodos = function() {
        if (!todoListElement) return;
        
        todoListElement.innerHTML = '';
        
        for (let i = 0; i < todos.length; i++) {
            const todo = todos[i];
            const li = document.createElement('li');
            li.className = todo.completed ? 'completed' : '';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = todo.completed;
            checkbox.dataset.index = i;
            checkbox.setAttribute('aria-label', 'Marquer "' + todo.text + '" comme ' + (todo.completed ? 'non complÃ©tÃ©e' : 'complÃ©tÃ©e'));
            
            const span = document.createElement('span');
            span.textContent = todo.text;
            span.dataset.index = i;
            
            const deleteBtn = document.createElement('button');
            deleteBtn.innerHTML = '&#x2715;';
            deleteBtn.dataset.index = i;
            deleteBtn.setAttribute('aria-label', 'Supprimer "' + todo.text + '"');
            deleteBtn.title = 'Supprimer la tÃ¢che';
            deleteBtn.type = 'button';
            
            li.appendChild(checkbox);
            li.appendChild(span);
            li.appendChild(deleteBtn);
            todoListElement.appendChild(li);
        }
        
        if (todoCountElement) {
            todoCountElement.textContent = todos.length;
        }
        
        saveState('todos', todos);
    };

    const addTodo = function() {
        if (!newTodoInput) return;
        
        const text = newTodoInput.value.trim();
        if (text) {
            todos.unshift({ text: text, completed: false });
            newTodoInput.value = '';
            renderTodos();
            console.log('TÃ¢che ajoutÃ©e:', text);
        }
    };

    if (addTodoButton) {
        addTodoButton.addEventListener('click', function() {
            console.log('Clic bouton ajouter tÃ¢che');
            addTodo();
        });
    }
    
    if (newTodoInput) {
        newTodoInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addTodo();
            }
        });
    }
    
    if (todoListElement) {
        todoListElement.addEventListener('click', function(e) {
            const index = e.target.dataset.index;
            if (index === undefined) return;
            
            const idx = parseInt(index);
            
            if (e.target.type === 'checkbox' || e.target.tagName === 'SPAN') {
                todos[idx].completed = !todos[idx].completed;
                console.log('TÃ¢che modifiÃ©e:', todos[idx].text);
            } else if (e.target.tagName === 'BUTTON') {
                console.log('TÃ¢che supprimÃ©e:', todos[idx].text);
                todos.splice(idx, 1);
            }
            
            renderTodos();
        });
    }
    
    renderTodos();
    console.log('âœ… To-Do initialisÃ©e');

    // ========================================================== //
    // 10. MINUTEUR POMODORO
    // ========================================================== //
    
    let WORK_DURATION = loadState('workDuration', 25) * 60;
    let BREAK_DURATION = loadState('breakDuration', 5) * 60;
    let totalSeconds = WORK_DURATION;
    let isRunning = false;
    let intervalId = null;
    let isWorkSession = true;
    let sessionsCompleted = loadState('sessionsCompleted', 0);

    const updatePomodoroSettings = function() {
        if (!workDurationInline || !breakDurationInline) return;
        
        const newWorkMin = parseInt(workDurationInline.value);
        const newBreakMin = parseInt(breakDurationInline.value);
        
        if (newWorkMin > 0 && newWorkMin <= 60) {
            WORK_DURATION = newWorkMin * 60;
            saveState('workDuration', newWorkMin);
        }
        
        if (newBreakMin > 0 && newBreakMin <= 30) {
            BREAK_DURATION = newBreakMin * 60;
            saveState('breakDuration', newBreakMin);
        }
        
        if (!isRunning) {
            resetTimer(true);
        }
    };

    const updateDisplay = function() {
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        
        if (timerDisplay) {
            timerDisplay.textContent = (minutes < 10 ? '0' : '') + minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
        }
        
        if (sessionCountElement) {
            sessionCountElement.textContent = sessionsCompleted;
        }
    };

    const updateStatus = function() {
        if (!timerStatus || !startTimerButton) return;
        
        const durationMin = isWorkSession 
            ? Math.floor(WORK_DURATION / 60) 
            : Math.floor(BREAK_DURATION / 60);
        
        if (isWorkSession) {
            timerStatus.textContent = isRunning 
                ? 'FOCUS : Travail en cours' 
                : 'PrÃªt pour Focus (' + durationMin + ' min)';
            startTimerButton.innerHTML = isRunning 
                ? '<i class="fas fa-pause"></i> Pause' 
                : '<i class="fas fa-play"></i> DÃ©marrer Focus';
        } else {
            timerStatus.textContent = isRunning 
                ? 'PAUSE : DÃ©tente active' 
                : 'PrÃªt pour Pause (' + durationMin + ' min)';
            startTimerButton.innerHTML = isRunning 
                ? '<i class="fas fa-pause"></i> Pause' 
                : '<i class="fas fa-play"></i> DÃ©marrer Pause';
        }
    };

    const countdown = function() {
        totalSeconds--;
        
        if (totalSeconds < 0) {
            clearInterval(intervalId);
            
            if (isWorkSession) {
                sessionsCompleted++;
                saveState('sessionsCompleted', sessionsCompleted);
            }
            
            const message = isWorkSession 
                ? "â° Temps de Focus terminÃ© ! C'est l'heure de la pause." 
                : "â° Pause terminÃ©e ! Reprenons le travail.";
            
            alert(message);
            
            isWorkSession = !isWorkSession;
            totalSeconds = isWorkSession ? WORK_DURATION : BREAK_DURATION;
            intervalId = setInterval(countdown, 1000);
        }
        
        updateDisplay();
        updateStatus();
    };

    const toggleTimer = function() {
        isRunning = !isRunning;
        console.log('Timer:', isRunning ? 'dÃ©marrÃ©' : 'pausÃ©');
        
        if (isRunning) {
            intervalId = setInterval(countdown, 1000);
        } else {
            clearInterval(intervalId);
        }
        
        updateStatus();
    };

    const resetTimer = function(toWork) {
        if (toWork === undefined) toWork = true;
        clearInterval(intervalId);
        isRunning = false;
        isWorkSession = toWork;
        totalSeconds = isWorkSession ? WORK_DURATION : BREAK_DURATION;
        updateDisplay();
        updateStatus();
        console.log('Timer rÃ©initialisÃ©');
    };

    if (workDurationInline && breakDurationInline) {
        workDurationInline.value = loadState('workDuration', 25);
        breakDurationInline.value = loadState('breakDuration', 5);
        
        workDurationInline.addEventListener('change', function() {
            console.log('DurÃ©e travail changÃ©e');
            updatePomodoroSettings();
        });
        
        breakDurationInline.addEventListener('change', function() {
            console.log('DurÃ©e pause changÃ©e');
            updatePomodoroSettings();
        });
        
        resetTimer(true);
    }

    if (startTimerButton) {
        startTimerButton.addEventListener('click', function() {
            console.log('Clic dÃ©marrer/pause timer');
            toggleTimer();
        });
    }
    
    if (resetTimerButton) {
        resetTimerButton.addEventListener('click', function() {
            console.log('Clic rÃ©initialiser timer');
            resetTimer(true);
        });
    }

    console.log('âœ… Pomodoro initialisÃ©');

    // ========================================================== //
    // 11. ZONE DE DESSIN
    // ========================================================== //
    
    if (canvas) {
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'pencil';
        let currentColor = loadState('drawingColor', '#333333');
        let currentBrushSize = loadState('brushSize', 3);

        const setupCanvas = function() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.fillStyle = body.classList.contains('dark-mode') ? '#212932' : '#f0f3f6';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            updateDrawingStyle();
        };

        const updateDrawingStyle = function() {
            if (currentTool === 'pencil') {
                ctx.strokeStyle = currentColor;
                ctx.globalCompositeOperation = 'source-over';
                canvas.classList.remove('eraser-mode');
            } else {
                ctx.strokeStyle = body.classList.contains('dark-mode') ? '#212932' : '#f0f3f6';
                ctx.globalCompositeOperation = 'destination-out';
                canvas.classList.add('eraser-mode');
            }
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = currentBrushSize;
        };

        setupCanvas();
        window.addEventListener('resize', setupCanvas);
        
        if (toolPencilButton) {
            toolPencilButton.addEventListener('click', function() {
                currentTool = 'pencil';
                toolPencilButton.classList.add('active-tool');
                toolEraserButton.classList.remove('active-tool');
                updateDrawingStyle();
                console.log('Outil: crayon');
            });
        }
        
        if (toolEraserButton) {
            toolEraserButton.addEventListener('click', function() {
                currentTool = 'eraser';
                toolEraserButton.classList.add('active-tool');
                toolPencilButton.classList.remove('active-tool');
                updateDrawingStyle();
                console.log('Outil: gomme');
            });
        }
        
        if (colorPicker) {
            colorPicker.value = currentColor;
            colorPicker.addEventListener('input', function(e) {
                currentColor = e.target.value;
                saveState('drawingColor', currentColor);
                if (currentTool === 'pencil') {
                    ctx.strokeStyle = currentColor;
                }
            });
        }
        
        if (brushSize && brushSizeValue) {
            brushSize.value = currentBrushSize;
            brushSizeValue.textContent = currentBrushSize;
            
            brushSize.addEventListener('input', function(e) {
                currentBrushSize = parseInt(e.target.value);
                brushSizeValue.textContent = currentBrushSize;
                ctx.lineWidth = currentBrushSize;
                saveState('brushSize', currentBrushSize);
            });
        }
        
        const getCoords = function(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
            const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
            return [clientX - rect.left, clientY - rect.top];
        };
        
        const draw = function(e) {
            if (!isDrawing) return;
            
            const coords = getCoords(e);
            const currentX = coords[0];
            const currentY = coords[1];
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            
            lastX = currentX;
            lastY = currentY;
        };

        const startDrawing = function(e) {
            isDrawing = true;
            const coords = getCoords(e);
            lastX = coords[0];
            lastY = coords[1];
            e.preventDefault();
        };

        const stopDrawing = function() {
            isDrawing = false;
        };

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);
        
        if (clearCanvasButton) {
            clearCanvasButton.addEventListener('click', function() {
                console.log('Canvas effacÃ©');
                setupCanvas();
            });
        }

        console.log('âœ… Canvas initialisÃ©');
    }
    
    // ========================================================== //
    // FINALISATION
    // ========================================================== //
    
    console.log('âœ…âœ…âœ… Focus & Zen complÃ¨tement initialisÃ© !');
});
